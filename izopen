#!/bin/bash
NAME="izopen"
DESCRIPTION="multi protocol bash script to auto opening given URI and auto creating ssh reverse tunnel socks proxy"
VERSION="3.1.0"
VERSION_DATE="20251102"

################################################################################
# izOpen - Multi-Protocol URI Launcher with SSH Tunnel Support
# written by Ugo Viti <u.viti@wearequantico.it>
#
# izOpen is a versatile URI launcher designed for password managers like
# KeePassXC, with automatic SSH reverse tunnel SOCKS proxy management.
################################################################################

## FEATURES:
# - Supported URI schemas: ssh, rdp, vnc, sftp, ftp, http, https, smb, cifs
# - Automatic SSH reverse tunnel (SOCKS proxy) creation and management
# - Per-host tunnel port persistence
# - Clipboard password integration (X11 + Wayland support)
# - Multiple RDP clients: rdesktop, xfreerdp 3.x, remmina, krdc
# - Multiple VNC clients: vncviewer, remmina, krdc
# - Multiple dialog tools: zenity, kdialog, yad (auto-detected)
# - Terminal emulator auto-detection (KDE, GNOME, MATE, XFCE)
# - Domain parsing for RDP (supports DOMAIN/user and user@DOMAIN)
# - Automatic Remmina config generation
# - URL encoding for krdc passwords (special characters support)
# - Proxychains4 integration for tunnel connections

## INSTALLATION:
# Copy this script to a directory in your PATH:
#   cp izopen ~/bin   # or /usr/local/bin for system-wide
#
# Install dependencies (Fedora/RHEL):
#   sudo dnf install -y proxychains-ng xdg-utils yad zenity kdialog \
#     openssh-clients sshpass telnet nmap-ncat xsel wl-clipboard \
#     freerdp remmina keepassxc krdc tigervnc
#
# For other distributions, install equivalent packages.

## CONFIGURATION:
# User config: $HOME/.config/izopen/izopen.conf (auto-created on first run)
# Override any default by setting variables in config file:
#   helper_cmd[rdp]="xfreerdp"    # Choose RDP client
#   helper_cmd[vnc]="krdc"        # Choose VNC client
#   tunnel_port_min=3000          # Set tunnel port range
#   clipboard_use=0               # Disable clipboard integration

## PASSWORD ESCAPING NOTES:
# - xfreerdp 3.x: NO escaping needed (bash arrays handle special chars)
# - rdesktop: NO escaping needed
# - krdc: REQUIRES URL encoding (% ‚Üí %25, ! ‚Üí %21, @ ‚Üí %40, etc.)
# - vncviewer: NO escaping needed

## KEEPASSX/KEEPASSXC INTEGRATION:
# In KeePassXC settings, set "Custom Browser Command":
#   izopen %1
#
# In database entries, use URI field with placeholders:
#   rdp://{USERNAME}:{PASSWORD}@server.example.com:3389
#   rdp://DOMAIN/{USERNAME}:{PASSWORD}@server:3389
#   vnc://{PASSWORD}@server:5902
#   ssh://{USERNAME}:{PASSWORD}@server:22
#
# Placeholders {USERNAME} and {PASSWORD} are automatically replaced.

## DESKTOP INTEGRATION (MIME handler):
# See README.md for registering izopen as default handler for:
#   ssh://, rdp://, vnc:// URIs system-wide

################################################################################
# SECURITY CONSIDERATIONS - READ CAREFULLY
################################################################################
#
# ‚ö†Ô∏è  This script handles passwords and has inherent security risks:
#
# 1. SSHPASS ENVIRONMENT VARIABLE (helper_ssh)
#    - Password exported as SSHPASS (visible in /proc/<pid>/environ)
#    - Cleaned after execution, but window of exposure exists
#    - Alternative: Use SSH keys + ssh-agent instead
#
# 2. StrictHostKeyChecking=no (DEFAULT - Line 248)
#    - üî¥ CRITICAL: Vulnerable to Man-in-the-Middle attacks
#    - Automatically accepts unknown SSH host keys
#    - Override in config: helper_opts[ssh]="-o StrictHostKeyChecking=ask"
#    - ONLY use on trusted networks
#
# 3. REMMINA CONFIG FILES
#    - Passwords saved in plaintext: ~/.cache/izopen/rdp.remmina
#    - Files should have 600 permissions (user read/write only)
#    - Temporary but persistent until next connection
#
# 4. PASSWORD LOGGING
#    - Passwords ARE sanitized from logs (sanitize_uri_for_logging)
#    - Log file: ~/.config/izopen/izopen.log (should be 600 permissions)
#
# 5. CLIPBOARD HANDLING
#    - Passwords read from clipboard (other processes may see)
#    - Clipboard cleared after read (workaround method)
#    - Brief window of exposure
#
# RECOMMENDATIONS:
# - Use SSH keys instead of passwords when possible
# - Enable StrictHostKeyChecking in trusted environments
# - Run on trusted systems only (not shared computers)
# - Review ~/.config/izopen/izopen.log permissions
# - Consider this tool for convenience vs high-security environments
#
################################################################################

# Declare helper variables as associative arrays
declare -A helper_name helper_cmd helper_opts helper_conf

# Declare izopen_connect as an indexed array
declare -a izopen_connect=()

## mandatory system commands based on operating system
#########################################################################

# Configure environment for Linux/Unix systems
# Sets default helper commands for each protocol (ssh, rdp, vnc, http, etc.)
# Configures clipboard commands based on session type (Wayland vs X11)
# Auto-detects terminal emulator based on desktop environment (KDE, GNOME, MATE, XFCE)
# All settings can be overridden in user config file
function env_os_linux() {
  system_commands="nc xdg-open ssh sshpass telnet proxychains jq"

  ## misc options
  : ${clipboard_use:=1}

  ## helper commands

  # default command for SSH
  : ${helper_cmd[ssh]:="ssh"}

  # default command for SFTP
  : ${helper_cmd[sftp]:="ssh"}

  # default command for TELNET
  : ${helper_cmd[telnet]:="telnet"}

  # default command for HTTP/S
  #: ${helper_cmd[http]:="midori"}
  : ${helper_cmd[http]:="google-chrome"}

  # default command for RDP
  #: ${helper_cmd[rdp]:="rdesktop"}
  #: ${helper_cmd[rdp]:="xfreerdp"}
  : ${helper_cmd[rdp]:="remmina"}

  # # default command for VNC
  #: ${helper_cmd[vnc]:="vncviewer"}
  : ${helper_cmd[vnc]:="remmina"}

  # # default command for FTP
  : ${helper_cmd[ftp]:="xdg-open"}

  # # default command for SMB/CIFS
  : ${helper_cmd[smb]:="xdg-open"}
  : ${helper_cmd[cifs]:="xdg-open"}

  # clipboard management
  case "$XDG_SESSION_TYPE" in
    wayland)
      : ${clipboard_cmd:="wl-paste"}
      : ${clipboard_cmd_paste:="wl-paste -n"}
      : ${clipboard_cmd_clear:="wl-copy -o"}
      ;;
    *)
      # X11 failback
      : ${clipboard_cmd:="xsel"}
      : ${clipboard_cmd_paste:="xsel -b"}
      : ${clipboard_cmd_clear:="xsel -b -i"}
      ;;
  esac

  # default terminal app
  # define the command to use based on current desktop environment
  if [ ! -z "${helper_cmd[terminal]}" ]; then
      : ${helper_name[terminal]:="${helper_cmd[terminal]}"}
  else
    case "$XDG_CURRENT_DESKTOP" in
      KDE)      : ${helper_name[terminal]:="konsole"} ;;
      GNOME)    : ${helper_name[terminal]:="$(gsettings get org.gnome.desktop.default-applications.terminal exec | tr -d \')"} ;;
      MATE)     : ${helper_name[terminal]:="$(gsettings get org.mate.applications-terminal exec | tr -d \')"} ;;
      XFCE)     : ${helper_name[terminal]:="exo-open --launch TerminalEmulator"} ;;
      Pantheon) : ${helper_name[terminal]:="exo-open --launch TerminalEmulator"} ;;
      *)        : ${helper_name[terminal]:="xterm"} ;;
    esac
  fi

  : ${helper_cmd[terminal]:="${helper_name[terminal]}"}
}

# Configure environment for Windows (Cygwin/MSYS2) systems
# Sets default helper commands optimized for Windows environment
# Disables clipboard_use by default (clipboard integration issues on Windows)
# Uses Windows-specific paths for Chrome and sets mintty as default terminal
function env_os_windows() {
  system_commands="nc ssh sshpass telnet yad"

  ## misc options
  : ${clipboard_use:=0}

  ## helper commands

  # default command for SSH
  : ${helper_cmd[ssh]:="ssh"}

  # default command for SFTP
  : ${helper_cmd[sftp]:="ssh"}

  # default command for HTTP/S
  : ${helper_name[http]:="google-chrome"}
  : ${helper_cmd[http]:="/cygdrive/c/Program Files/Google/Chrome/Application/chrome.exe"}

  # default command for RDP
  : ${helper_cmd[rdp]:="xfreerdp"}

  # # default command for VNC
  : ${helper_cmd[vnc]:="vncviewer"}

  # # default command for FTP
  : ${helper_cmd[ftp]:="xdg-open"}

  # # default command for SMB/CIFS
  : ${helper_cmd[smb]:="xdg-open"}
  : ${helper_cmd[cifs]:="xdg-open"}

  # default terminal app
  : ${helper_cmd[terminal]:="mintty"}
}

## vars
#########################################################################
_PROG=$( echo ${0##*/} )     # define the command name

: ${debug:=0}                # enable script debug
: ${terminal_use:=1}         # open compatible schema using external terminal gui
: ${tunnel_create:=1}        # try to create a new ssh tunnel when connecting via ssh
: ${tunnel_use:=1}           # use the existing ssh tunnel
: ${tunnel_use_force:=0}     # always use the tunnel for every opened uri (also for ssh it self)
: ${tunnel_port_min:=2000}   # minimun tunnel port number to use
: ${tunnel_port_max:=65535}  # maximun tunnel port number to use

# default izopen config file
izopen_conf_dir="$HOME/.config/izopen"
izopen_cache_dir="$HOME/.cache/izopen"
izopen_conf_file="$izopen_conf_dir/izopen.conf"
izopen_conf_tunnels_json="$izopen_conf_dir/tunnels.json"
izopen_conf_proxychains_conf="$izopen_cache_dir/proxy.conf"

# Legacy paths (for cleanup only)
izopen_conf_hosts_dir="$izopen_conf_dir/hosts"

# make dirs if not exist
[ ! -e "$izopen_conf_dir" ] && mkdir -p "$izopen_conf_dir"
[ ! -e "$izopen_cache_dir" ] && mkdir -p "$izopen_cache_dir"

# ensure secure permissions on directories (always, even if they already exist)
chmod 700 "$izopen_conf_dir" 2>/dev/null
chmod 700 "$izopen_cache_dir" 2>/dev/null

# izopen log file - create if doesn't exist and ensure secure permissions
izopen_log_file="$izopen_conf_dir/izopen.log"
[ ! -e "$izopen_log_file" ] && touch "$izopen_log_file"
chmod 600 "$izopen_log_file" 2>/dev/null

# import configuration from izopen.conf if exist and override default script variables
[ -f "${izopen_conf_file}" ] && source "${izopen_conf_file}"

# detect operating system and import the right system variables
case "$OSTYPE" in
  linux*)   env_os_linux ;; # running in linux env
  solaris*) env_os_linux ;; # WIP
  darwin*)  env_os_linux ;; # WIP
  bsd*)     env_os_linux ;; # WIP
  msys*)    env_os_windows ;; # running in windows env
  cygwin*)  env_os_windows ;; # running in windows env
  *)        env_os_linux ;; # always failback to linux env
esac

# commands helper functions
#########################################################################
function make_default_config() {
  cat <<EOF
### terminal options
#helper_cmd[terminal]="konsole"
#helper_opts[terminal]="--noclose"


### ssh options
#helper_cmd[ssh]="ssh"
helper_opts[ssh]="-o StrictHostKeyChecking=no -o CheckHostIP=no"


### rdp options
## rdesktop
#helper_cmd[rdp]="rdesktop"
#helper_opts[rdp]="-k it -g 1280x780"

## freerdp
#helper_cmd[rdp]="xfreerdp"
#helper_opts[rdp]="/drive:/tmp /kbd:0x00020409"

## remmina
helper_cmd[rdp]="remmina"
helper_conf[rdp]="drive=/tmp window_maximize=0 window_width=1600 window_height=1000 tls-seclevel=0 ignore-tls-errors=1"

## krdc (KDE Remote Desktop Client)
#helper_cmd[rdp]="krdc"
#helper_opts[rdp]="--fullscreen"


### browser options
#helper_cmd[http]="google-chrome"
#helper_opts[http]="--proxy-bypass-list='<-loopback>'"

## for windows browser support define helper_name[http] too
#helper_name[http]="google-chrome"
#helper_cmd[http]:="/c/Program\ Files/Google/Chrome/Application/chrome.exe"}


### vnc options
## vncviewer
#helper_cmd[vnc]="vncviewer"

## remmina
#helper_cmd[vnc]="remmina"
#helper_conf[vnc]="window_maximize=0 window_width=1600 window_height=1000"

## krdc (KDE Remote Desktop Client)
#helper_cmd[vnc]="krdc"
#helper_opts[vnc]="--fullscreen"

## others uri
#helper_cmd[ftp]="xdg-open"
#helper_cmd[telnet]="telnet"
#helper_cmd[smb]="xdg-open"
#helper_cmd[cifs]="xdg-open"

## misc options
#debug=1
#nc_opts="-z"
#terminal_use=0
#tunnel_use_force=1
#clipboard_use=0
EOF
}

function check_system_commands() {
  # verify if all commands are installed in the system paths
  for COMMAND in $@
    do
      which "$COMMAND" >/dev/null 2>&1
      [ $? -ne 0 ] && echo "WARNING: the command '$COMMAND' doesn't exist in any path, please install it and retry"
    done
}

function check_helper_cmd() {
  which "$@" >/dev/null 2>&1
  [ $? -ne 0 ] && echo "WARNING: the command '$@' doesn't exist in any path, please install it and retry"
}

#########################################################################
# SHARED HELPER INFRASTRUCTURE
# Common functions used by all protocol helpers to reduce code duplication
#########################################################################

# Initialize helper connection for any protocol
# Sets helper name, checks command exists, resets connection array
# Usage: init_helper_connection "protocol_name"
function init_helper_connection() {
  local protocol="$1"

  # Set helper name if not defined
  [ -z "${helper_name[$protocol]}" ] && helper_name[$protocol]="${helper_cmd[$protocol]}"

  # Verify command exists
  check_helper_cmd "${helper_cmd[$protocol]}"

  # Reset connection array
  izopen_connect=()
}

# Add protocol-specific options to connection array
# Parses helper_opts[protocol] and adds to izopen_connect array
# Usage: add_helper_opts "protocol_name"
function add_helper_opts() {
  local protocol="$1"

  if [ -n "${helper_opts[$protocol]}" ]; then
    local -a opts_array
    read -ra opts_array <<< "${helper_opts[$protocol]}"
    izopen_connect+=("${opts_array[@]}")
  fi
}

# Wrap command with terminal emulator if terminal_use=1
# Prepends terminal command and options to izopen_connect array
# Usage: wrap_with_terminal (call after building izopen_connect)
function wrap_with_terminal() {
  [ "$terminal_use" != 1 ] && return

  # Build terminal command
  helper_terminal

  local -a terminal_cmd=("${helper_cmd[terminal]}")

  # Add terminal options if any
  if [ ${#terminal_opts_array[@]} -gt 0 ]; then
    terminal_cmd+=("${terminal_opts_array[@]}")
  fi

  # Add execute flag
  terminal_cmd+=("-e")

  # Prepend terminal wrapper to connection command
  izopen_connect=("${terminal_cmd[@]}" "${izopen_connect[@]}")
}

# Generate unified Remmina configuration file
# Supports both RDP and VNC protocols with protocol-specific settings
# Usage: generate_remmina_config "protocol" "server" "config_file_path"
# Variables used: $host, $tunnel_use, $tunnel_port_use, $username, $password, $domain (RDP only)
function generate_remmina_config() {
  local protocol="$1"
  local server="$2"
  local conf_file="$3"

  # Protocol-specific settings
  local protocol_upper="${protocol^^}"  # Convert to uppercase (RDP, VNC)
  local extra_settings=""

  case "$protocol" in
    rdp)
      extra_settings="resolution_mode=2
scale=2"
      ;;
    vnc)
      extra_settings="scale=1
ignore-tls-errors=1"
      ;;
  esac

  # Generate config
  #$([ $tunnel_use = 1 ] && echo -e "proxy_type=socks5\nproxy_hostname=127.0.0.1\nproxy_port=$tunnel_port_use")
  cat > "$conf_file" <<EOF
[remmina]
name=$host
protocol=$protocol_upper
viewmode=1
window_maximize=1
$extra_settings
server=$server
$([ ! -z "$domain" ] && [ "$protocol" = "rdp" ] && echo "domain=$domain")
$([ ! -z "$username" ] && echo "username=$username")
$([ ! -z "$password" ] && echo "password=$password")
$(for conf in ${helper_conf[$protocol]}; do echo -e "$conf\n";done)
EOF

  # Set secure permissions (password is stored in plaintext)
  chmod 600 "$conf_file"
}

# Configure terminal emulator options for wrapping commands
# Sets terminal-specific options (title, colors, profile properties)
# Distinguishes between MASTER (tunnel creator) and SLAVE (tunnel user) sessions
# Populates terminal_opts_array with terminal-specific flags
# Supports: konsole (KDE), mintty (Windows), generic terminals
function helper_terminal() {
  # if helper_name[$schema] is not defined, use the helper_cmd[$schema] instead
  [ -z "${helper_name[terminal]}" ] && helper_name[terminal]="${helper_cmd[terminal]}"

  # verify if the command exist
  check_helper_cmd "${helper_cmd[terminal]}"

  if [ "$tunnel_create" = 1 ]; then
     local terminal_title="H:$host P:$tunnel_port_create [MASTER]"
   else
     local terminal_title="H:$host P:$tunnel_port_create [SLAVE]"
  fi

  # Initialize terminal options array
  terminal_opts_array=()

  # Parse any pre-configured options from config file
  if [ -n "${helper_opts[terminal]}" ]; then
    read -ra terminal_opts_array <<< "${helper_opts[terminal]}"
  fi

  # Add terminal-specific options directly to array
  case ${helper_name[terminal]} in
    konsole)
      ## for a usable list:
      ## konsole --list-profile-properties | less
      #terminal_opts_array+=(-p "tabtitle=(%u) %H")
      terminal_opts_array+=(-p "name=$host")
      terminal_opts_array+=(-p "LocalTabTitleFormat=$terminal_title")
      terminal_opts_array+=(-p "RemoteTabTitleFormat=$terminal_title")
      terminal_opts_array+=(-p "TabColor=#aa55ff")
      terminal_opts_array+=(-p "UseCustomCursorColor=true")
      terminal_opts_array+=(-p "CustomCursorColor=orange")
      terminal_opts_array+=(--show-tabbar)
      #terminal_opts_array+=(--noclose)
      ;;
    mintty)
      terminal_opts_array+=(-T "$terminal_title")
      ;;
    *)
      #echo helper_name[terminal]: ${helper_name[terminal]}
      terminal_opts_array+=(--title="$terminal_title")
      ;;
  esac
}

#########################################################################
# DIALOG FUNCTIONS - Support for zenity, kdialog and yad
#########################################################################

# Detect desktop environment and select appropriate dialog tool
function detect_dialog_tool() {
  # Default to zenity if available, otherwise fallback to yad
  if command -v zenity &> /dev/null; then
    dialog_tool="zenity"
  else
    dialog_tool="yad"
  fi
}

# RDP connection form dialog
function dialog_form_rdp() {
  local domain="$1"
  local host="$2"
  local username="$3"
  local password="$4"

  case "$dialog_tool" in
    kdialog)
      # kdialog: use multiple sequential input boxes
      local d=$(kdialog --inputbox "Domain:" "$domain" 2>/dev/null)
      [ $? -ne 0 ] && return 1
      local h=$(kdialog --inputbox "Address:" "$host" 2>/dev/null)
      [ $? -ne 0 ] && return 1
      local u=$(kdialog --inputbox "Username:" "$username" 2>/dev/null)
      [ $? -ne 0 ] && return 1
      local p=$(kdialog --password "Password:" 2>/dev/null)
      [ $? -ne 0 ] && return 1
      # Use default values for security (nla) and console (FALSE)
      echo "$d|$h|$u|$p|nla|FALSE"
      ;;
    zenity)
      # zenity: use forms
      zenity --forms --title="Connect to remote computer" --width=400 \
        --text="RDP Connection" \
        --add-entry="Domain" \
        --add-entry="Address" \
        --add-entry="Username" \
        --add-password="Password" \
        --add-combo="Security" --combo-values="rdp|tls|nla|ext" \
        --separator="|" 2>/dev/null
      ;;
    *)
      # yad: original form with all fields
      LANG=C yad --center --width=300 --title="Connect to remote computer" \
        --focus-field=4 --align=right --form \
        --field="Domain" "$domain" \
        --field="Address" "$host" \
        --field="Username" "$username" \
        --field="Password":H "$password" \
        --field="Security":CB 'rdp!tls!^nla!ext' \
        --field="Admin Console":CHK 2>/dev/null | \
        grep -v "WINDOW DECORATIONS RELOADED"
      ;;
  esac
}

# VNC connection form dialog
function dialog_form_vnc() {
  local host="$1"
  local username="$2"
  local password="$3"

  case "$dialog_tool" in
    kdialog)
      # kdialog: use multiple sequential input boxes
      local h=$(kdialog --inputbox "Address:" "$host" 2>/dev/null)
      [ $? -ne 0 ] && return 1
      local u=$(kdialog --inputbox "Username:" "$username" 2>/dev/null)
      [ $? -ne 0 ] && return 1
      local p=$(kdialog --password "Password:" 2>/dev/null)
      [ $? -ne 0 ] && return 1
      echo "$h|$u|$p"
      ;;
    zenity)
      # zenity: use forms
      zenity --forms --title="Connect to remote computer" --width=400 \
        --text="VNC Connection" \
        --add-entry="Address" \
        --add-entry="Username" \
        --add-password="Password" \
        --separator="|" 2>/dev/null
      ;;
    *)
      # yad: original form
      LANG=C yad --center --width=300 --title="Connect to remote computer" \
        --focus-field=3 --align=right --form \
        --field="Address" "$host" \
        --field="Username" "$username" \
        --field="Password":H "$password" 2>/dev/null | \
        grep -v "WINDOW DECORATIONS RELOADED"
      ;;
  esac
}

# SSH tunnel port entry dialog
function dialog_entry_port() {
  local default_port="$1"
  local min="$2"
  local max="$3"

  case "$dialog_tool" in
    kdialog)
      kdialog --inputbox "Inserire porta SOCKS proxy ($min-$max):" "$default_port" 2>/dev/null
      ;;
    zenity)
      zenity --entry --title="izOpen SSH Proxy" --width=300 \
        --text="Inserire porta SOCKS proxy ($min-$max):" \
        --entry-text="$default_port" 2>/dev/null
      ;;
    *)
      LANG=C yad --center --title="izOpen SSH Proxy" --entry --numeric \
        --entry-text=$default_port \
        --text="<b>Inserire la porta del Proxy Socks</b> \nCompresa fra $min e $max\n" \
        $min $max --timeout=10 --timeout-indicator=bottom 2>/dev/null | \
        tr -d [:alpha:] | tr -d [:cntrl:] | tr -d [:space:]
      ;;
  esac
}

# Connection error log viewer dialog
function dialog_text_info() {
  local log_file="$1"
  local log_content

  # Extract relevant log entries
  log_content=$(tail -n 350 "$log_file" | sed -n "H; /^$(date '+%Y-%m-%d')/h; \${g;p;}")

  case "$dialog_tool" in
    kdialog)
      echo "$log_content" | kdialog --textbox /dev/stdin 100 40 --title "Connection Error" 2>/dev/null
      ;;
    zenity)
      echo "$log_content" | zenity --text-info --title="Connection Error" --width=1000 --height=500 2>/dev/null
      ;;
    *)
      echo "$log_content" | LANG=C yad --center --width=1000 --height=500 \
        --title="Connection Error" --button="Close":0 \
        --text="Errors from ${log_file}" \
        --text-info --fontname="Monospace 8" 2>/dev/null
      ;;
  esac
}

function helper_ssh() {
  # Initialize connection (sets helper name, checks command, resets array)
  init_helper_connection "ssh"

  # password less ssh login using sshpass
  # FIXME don't use sshpass outside linux environment because this bug:
  # https://github.com/msys2/MSYS2-packages/issues/2458
  case $OSTYPE in
    cygwin*|msys*)
      ;;
    *)
      if [ ! -z "$password" ]; then
        # pretty insecure, but the export is needed to avoid printing password into processlist
        export SSHPASS=$password
        izopen_connect+=(sshpass -e)
      fi
      ;;
  esac

  # add ssh command
  izopen_connect+=("${helper_cmd[ssh]}")

  # add ssh options
  add_helper_opts "ssh"

  # add username and host
  if [ ! -z "$username" ]; then
    izopen_connect+=("$username@$host")
  else
    izopen_connect+=("$host")
  fi

  # add the port if not default 22
  [ ! -z "$port" ] && izopen_connect+=(-p "$port")

  # enable compression
  izopen_connect+=(-C)

  # wrap with terminal if required (must be last)
  wrap_with_terminal

  # if tunnel_create=1 add ssh options to create socks tunnel
  [ "$tunnel_create" = 1 ] && izopen_connect+=(-D "$tunnel_port_create")
}

function helper_telnet() {
  # Initialize connection
  init_helper_connection "telnet"

  # add telnet command
  izopen_connect+=("${helper_cmd[telnet]}")

  # add telnet options
  add_helper_opts "telnet"

  # add host
  izopen_connect+=("$host")

  # add port if specified
  [ -n "$port" ] && izopen_connect+=("$port")

  # wrap with terminal if required (must be last)
  wrap_with_terminal
}

function helper_http() {
  # Initialize connection
  init_helper_connection "http"

  # run the connection
  case ${helper_name[http]} in
    google-chrome)
      izopen_connect+=("${helper_cmd[http]}")
      add_helper_opts "http"

      # open the browser with this options only on tunnel connection
      if [ $tunnel_use = 1 ]; then
        # Chrome handles proxy directly via --proxy-server, skip helper_prepend (proxychains)
        helper_prepend_skip=1

        # Chrome tunnel-specific options
        local -a chrome_tunnel_opts=(
          --aggressive-cache-discard
          --disable-notifications
          --enable-aggressive-domstorage-flushing
          --disable-client-side-phishing-detection
          --disable-gpu
          --restore-last-session
          --no-first-run
          --disable-translate
          --password-store=basic
          --proxy-server="socks5://127.0.0.1:$tunnel_port_use"
        )
        izopen_connect+=("${chrome_tunnel_opts[@]}")

        case $OSTYPE in
          cygwin*)
            # google chrome under windows workaround
            izopen_connect+=(--user-data-dir="$(cygpath -w "$izopen_conf_dir/google-chrome/$tunnel_port_use")")
            ;;
          *)
            izopen_connect+=(--user-data-dir="$izopen_conf_dir/google-chrome/$tunnel_port_use")
            ;;
        esac
      fi
      ;;
    midori)
      izopen_connect+=("${helper_cmd[http]}")
      add_helper_opts "http"
      izopen_connect+=(-c "$izopen_conf_dir/midori/$tunnel_port_use")
      ;;
    *)
      helper_cmd[http]="xdg-open"
      izopen_connect+=("${helper_cmd[http]}")
      add_helper_opts "http"
      ;;
  esac

  # add URI as last argument
  izopen_connect+=("${uri}")
}

#########################################################################
# RDP HELPER FUNCTIONS
# Split helper_rdp into specialized functions for better maintainability
#########################################################################

# Parse RDP domain from username
# Supports both DOMAIN/username and username@DOMAIN formats
# Modifies global variables: $domain, $username
function parse_rdp_domain() {
  # Using / or \ as domain separator, domain is the first part
  if [[ "$username" == *"/"* ]]; then
    domain="${username%%/*}"
    username="${username#*/}"
  # Using @ as domain separator, domain is the second part
  elif [[ "$username" == *"@"* ]]; then
    domain="${username##*@}"
    username="${username%%@*}"
  fi
}

# Validate RDP credentials and show dialog if incomplete
# Checks for empty or placeholder values in host, username, password
# Shows dialog form if credentials are incomplete
# Modifies global variables: $domain, $host, $username, $password, $security, $console
function validate_rdp_credentials() {
  if [[ -z "$host" || -z "$username" || -z "$password" || \
        "$username" == "{USERNAME}" || "$password" == "{PASSWORD}" || \
        "$username" == "%7BUSERNAME%7D" || "$password" == "%7BPASSWORD%7D" ]]; then

    local frmdata=$(dialog_form_rdp "$domain" "$host" "$username" "$password")
    [ $? != 0 ] && exit 1

    IFS='|' read -r domain host username password security console <<< "$frmdata"
  fi
}

# Helper function for rdesktop RDP client
function helper_rdp_rdesktop() {
  init_helper_connection "rdp"

  izopen_connect+=("${helper_cmd[rdp]}")
  add_helper_opts "rdp"

  # NOTE: rdesktop does not need password escaping with bash arrays
  [ -n "$domain" ]   && izopen_connect+=(-d "$domain")
  [ -n "$username" ] && izopen_connect+=(-u "$username")
  [ -n "$password" ] && izopen_connect+=(-p "$password")

  # Add host with optional port
  local port_suffix=""
  [ -n "$port" ] && port_suffix=":$port"
  izopen_connect+=("${host}${port_suffix}")
}

# Helper function for xfreerdp 3.x RDP client
function helper_rdp_xfreerdp() {
  init_helper_connection "rdp"

  izopen_connect+=("${helper_cmd[rdp]}")
  add_helper_opts "rdp"

  # NOTE: xfreerdp 3.x does not need password escaping when using bash arrays
  # The password is passed correctly as-is. Escaping causes authentication to fail.

  # xfreerdp >= 3.x default options
  izopen_connect+=(+clipboard +auto-reconnect /auto-reconnect-max-retries:2 /cache:bitmap:on +compression /gdi:hw -wallpaper /dynamic-resolution /size:85% /cert:ignore /log-level:ERROR)

  [ -n "$domain" ]   && izopen_connect+=(/d:"$domain")
  [ -n "$username" ] && izopen_connect+=(/u:"$username")

  if [ -n "$password" ]; then
    izopen_connect+=(/p:"$password")
  else
    izopen_connect+=(/p:'')
  fi

  [ -n "$port" ]              && izopen_connect+=(/port:"$port")
  [ -n "$security" ]          && izopen_connect+=(/sec:"$security")
  [ "$console" = "TRUE" ]     && izopen_connect+=(/console)

  izopen_connect+=(/v:"${host}")
}

# Helper function for Remmina RDP client
function helper_rdp_remmina() {
  # Remove legacy files
  [ -e "$izopen_conf_dir/remmina" ] && rm -f "$izopen_conf_dir"/remmina/*.remmina && rmdir "$izopen_conf_dir/remmina"

  # Create remmina config file
  local izopen_conf_remmina_conf="$izopen_cache_dir/rdp.remmina"
  local server
  [ -z "$port" ] && server="$host" || server="$host:$port"

  # Generate config using unified function
  generate_remmina_config "rdp" "$server" "$izopen_conf_remmina_conf"

  init_helper_connection "rdp"
  izopen_connect+=("${helper_cmd[rdp]}")
  add_helper_opts "rdp"
  izopen_connect+=(-c "${izopen_conf_remmina_conf}")
}

# Helper function for krdc RDP client
function helper_rdp_krdc() {
  init_helper_connection "rdp"

  izopen_connect+=("${helper_cmd[rdp]}")
  add_helper_opts "rdp"

  # Build RDP URL for krdc: rdp://[DOMAIN\username[:password]@]host[:port]
  local rdp_url="rdp://"

  if [ -n "$username" ]; then
    # Add domain prefix if present (DOMAIN\username format)
    [ -n "$domain" ] && rdp_url+="${domain}\\${username}" || rdp_url+="${username}"

    # Add password with URL encoding if present
    if [ -n "$password" ]; then
      # NOTE: krdc REQUIRES URL encoding for special characters (unlike xfreerdp 3.x)
      # Without encoding, passwords with %, !, @, etc. will fail authentication
      local password_encoded=$(printf %s "$password" | sed 's/%/%25/g; s/ /%20/g; s/!/%21/g; s/"/%22/g; s/#/%23/g; s/\$/%24/g; s/&/%26/g; s/'\''/%27/g; s/(/%28/g; s/)/%29/g; s/\*/%2A/g; s/+/%2B/g; s/,/%2C/g; s/:/%3A/g; s/;/%3B/g; s/=/%3D/g; s/?/%3F/g; s/@/%40/g; s/\[/%5B/g; s/\\/%5C/g; s/\]/%5D/g')
      rdp_url+=":${password_encoded}"
    fi

    rdp_url+="@"
  fi

  rdp_url+="${host}"
  [ -n "$port" ] && rdp_url+=":${port}"

  izopen_connect+=("${rdp_url}")
}

function helper_rdp() {
  # Set helper name if not defined
  [ -z "${helper_name[rdp]}" ] && helper_name[rdp]="${helper_cmd[rdp]}"

  # Verify command exists
  check_helper_cmd "${helper_cmd[rdp]}"

  # Parse domain from username (supports DOMAIN/user and user@DOMAIN)
  parse_rdp_domain

  # Validate credentials and show dialog if incomplete
  validate_rdp_credentials

  # Dispatch to client-specific function
  case ${helper_name[rdp]} in
    rdesktop) helper_rdp_rdesktop ;;
    xfreerdp) helper_rdp_xfreerdp ;;
    remmina)  helper_rdp_remmina ;;
    krdc)     helper_rdp_krdc ;;
  esac
}

#########################################################################
# VNC HELPER FUNCTIONS
# Split helper_vnc into specialized functions for better maintainability
#########################################################################

# Validate VNC credentials and show dialog if incomplete
# Checks for empty or placeholder values in host, username, password
# Shows dialog form if credentials are incomplete
# Modifies global variables: $host, $username, $password
function validate_vnc_credentials() {
  if [[ -z "$host" || -z "$username" || -z "$password" || \
        "$username" == "{USERNAME}" || "$password" == "{PASSWORD}" || \
        "$username" == "%7BUSERNAME%7D" || "$password" == "%7BPASSWORD%7D" ]]; then

    local frmdata=$(dialog_form_vnc "$host" "$username" "$password")
    [ $? != 0 ] && exit 1

    IFS='|' read -r host username password <<< "$frmdata"
  fi
}

# Helper function for vncviewer client
function helper_vnc_vncviewer() {
  init_helper_connection "vnc"

  izopen_connect+=("${helper_cmd[vnc]}")
  add_helper_opts "vnc"

  # NOTE: vncviewer does not need password escaping with bash arrays
  # VNC doesn't support username and typically uses keyring for password

  # Add host with optional port
  if [ -n "$port" ]; then
    izopen_connect+=("${host}:${port}")
  else
    izopen_connect+=("${host}")
  fi
}

# Helper function for Remmina VNC client
function helper_vnc_remmina() {
  # Remove legacy files
  [ -e "$izopen_conf_dir/remmina" ] && rm -f "$izopen_conf_dir"/remmina/*.remmina && rmdir "$izopen_conf_dir/remmina"

  # Create remmina config file
  local izopen_conf_remmina_conf="$izopen_cache_dir/vnc.remmina"
  local server
  [ -z "$port" ] && server="$host" || server="$host:$port"

  # Generate config using unified function
  generate_remmina_config "vnc" "$server" "$izopen_conf_remmina_conf"

  init_helper_connection "vnc"
  izopen_connect+=("${helper_cmd[vnc]}")
  add_helper_opts "vnc"
  izopen_connect+=(-c "${izopen_conf_remmina_conf}")
}

# Helper function for krdc VNC client
function helper_vnc_krdc() {
  init_helper_connection "vnc"

  izopen_connect+=("${helper_cmd[vnc]}")
  add_helper_opts "vnc"

  # Build VNC URL for krdc: vnc://[password@]host[:port]
  local vnc_url="vnc://"

  # Add password if present (VNC typically doesn't use username)
  [ -n "$password" ] && vnc_url+="${password}@"

  # Add host
  vnc_url+="${host}"

  # Add port if specified
  [ -n "$port" ] && vnc_url+=":${port}"

  izopen_connect+=("${vnc_url}")
}

function helper_vnc() {
  # Set helper name if not defined
  [ -z "${helper_name[vnc]}" ] && helper_name[vnc]="${helper_cmd[vnc]}"

  # Verify command exists
  check_helper_cmd "${helper_cmd[vnc]}"

  # Validate credentials and show dialog if incomplete
  validate_vnc_credentials

  # Dispatch to client-specific function
  case ${helper_name[vnc]} in
    vncviewer) helper_vnc_vncviewer ;;
    remmina)   helper_vnc_remmina ;;
    krdc)      helper_vnc_krdc ;;
  esac
}

function helper_sftp() {
  # For SFTP, just call helper_ssh function which handles everything
  helper_ssh
}

function helper_ftp() {
  # Initialize connection
  init_helper_connection "ftp"

  # add command
  izopen_connect+=("${helper_cmd[ftp]}")

  # add base options
  add_helper_opts "ftp"

  # add URI
  izopen_connect+=("${uri}")
}

function helper_smb() {
  # Initialize connection
  init_helper_connection "smb"

  # add command
  izopen_connect+=("${helper_cmd[smb]}")

  # add base options
  add_helper_opts "smb"

  # add URI
  izopen_connect+=("${uri}")
}

function helper_cifs() {
  # Initialize connection
  init_helper_connection "cifs"

  # add command
  izopen_connect+=("${helper_cmd[cifs]}")

  # add base options
  add_helper_opts "cifs"

  # add URI
  izopen_connect+=("${uri}")
}

# SYSTEM FUNCTIONS
# DON'T TOUCH ANYTHING BELLOW
#########################################################################

# Generate proxychains4 configuration for SOCKS5 tunnel
# Creates config with strict chain, proxy DNS, and custom timeouts
# Usage: make_proxychains_conf <port>
# Parameters:
#   $1 - SOCKS5 port number to use for tunnel
# Note: remote_dns_subnet=224, tcp_read_time_out=15000ms, tcp_connect_time_out=8000ms
function make_proxychains_conf() {
  cat <<EOF
strict_chain
#quiet_mode
proxy_dns
remote_dns_subnet 224
tcp_read_time_out 15000
tcp_connect_time_out 8000

[ProxyList]
socks5 127.0.0.1 $1
EOF
}

#########################################################################
# TUNNEL JSON DATABASE FUNCTIONS
# Manage tunnel port mappings in JSON format with metadata
#########################################################################

# Helper function to safely update JSON file with atomic write
# Usage: jq_update <jq_expression> <file>
# Example: jq_update '.tunnels["host"] = {...}' "$izopen_conf_tunnels_json"
function jq_update() {
  local jq_expr="$1"
  local file="$2"
  shift 2

  # Pass remaining arguments to jq (--arg, etc.)
  jq "$@" "$jq_expr" "$file" > "${file}.tmp" && \
    mv "${file}.tmp" "$file" && \
    chmod 600 "$file"
}

# Initialize tunnels.json file if it doesn't exist
# Creates empty JSON structure with version field
# Sets secure file permissions (600)
# Usage: tunnel_json_init
function tunnel_json_init() {
  if [ ! -e "$izopen_conf_tunnels_json" ]; then
    echo '{"version":"1.0","tunnels":{}}' > "$izopen_conf_tunnels_json"
    chmod 600 "$izopen_conf_tunnels_json"
  fi
}

# Get tunnel port for a given host from JSON database
# Returns port number or empty if host not found
# Usage: tunnel_json_get <host>
# Parameters:
#   $1 - Hostname or IP address
# Returns: Port number via stdout, or empty if not found
function tunnel_json_get() {
  local host="$1"

  [ ! -e "$izopen_conf_tunnels_json" ] && return 1

  jq -r ".tunnels[\"$host\"].port // empty" "$izopen_conf_tunnels_json" 2>/dev/null
}

# Set/update tunnel port for a given host in JSON database
# Creates new entry or updates existing with metadata
# New entries: sets created, last_used, connection_count=1
# Existing entries: updates last_used, increments connection_count
# Usage: tunnel_json_set <host> <port>
# Parameters:
#   $1 - Hostname or IP address
#   $2 - Port number
function tunnel_json_set() {
  local host="$1"
  local port="$2"
  local timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  # Initialize if doesn't exist
  tunnel_json_init

  # Backup before modifying
  [ -e "$izopen_conf_tunnels_json" ] && cp -p "$izopen_conf_tunnels_json" "$izopen_conf_tunnels_json.bak"

  # Check if host already exists
  local existing_port=$(tunnel_json_get "$host")

  if [ -z "$existing_port" ]; then
    # New entry: set all fields
    jq_update '.tunnels[$host] = {"port": ($port | tonumber), "created": $timestamp, "last_used": $timestamp, "connection_count": 1}' \
      "$izopen_conf_tunnels_json" \
      --arg host "$host" \
      --arg port "$port" \
      --arg timestamp "$timestamp"
  else
    # Existing entry: update last_used and increment connection_count
    jq_update '.tunnels[$host].last_used = $timestamp | .tunnels[$host].connection_count += 1' \
      "$izopen_conf_tunnels_json" \
      --arg host "$host" \
      --arg timestamp "$timestamp"
  fi
}

# Migrate legacy tunnel configuration from hosts/*.conf to tunnels.json
# Merges legacy .conf files with existing JSON data (existing entries take priority)
# Scans ~/.config/izopen/hosts/ directory for .conf files
# Extracts hostname and port from each file
# Uses file modification time for created/last_used timestamps
# Only adds hosts that don't already exist in JSON (non-destructive merge)
# Deletes legacy files and directory after successful migration
# Shows progress during migration
# Usage: migrate_legacy_tunnels
function migrate_legacy_tunnels() {
  # Skip if no legacy directory exists
  [ ! -d "$izopen_conf_hosts_dir" ] && return 0

  # Skip if no .conf files exist
  local conf_count=$(find "$izopen_conf_hosts_dir" -maxdepth 1 -type f -name '*.conf' 2>/dev/null | wc -l)
  [ "$conf_count" -eq 0 ] && return 0

  # Show migration start message
  echo "Migrating legacy tunnel configuration..."
  echo "Found $conf_count .conf files to process"

  # Initialize JSON if needed (ensures we have a base to merge into)
  tunnel_json_init

  # Backup existing JSON
  cp -p "$izopen_conf_tunnels_json" "$izopen_conf_tunnels_json.bak"

  # Process each .conf file and merge into existing JSON
  # IMPORTANT: Use process substitution instead of pipe to avoid subshell
  local migrated_count=0
  local skipped_count=0
  local processed_count=0
  local progress_interval=100

  while IFS= read -r conf_file; do
    # Extract sanitized hostname from filename (remove .conf extension)
    local hostname_sanitized=$(basename "$conf_file" .conf)

    # Restore original hostname by converting ALL underscores back to dots
    # The original sanitization: sed 's/[^A-Za-z0-9_-]/_/g' replaced all non-alphanumeric chars (including dots) with underscores
    # Examples: 10_1_1_26.conf ‚Üí 10.1.1.26, vpn01_quantico_srl.conf ‚Üí vpn01.quantico.srl
    local hostname=$(echo "$hostname_sanitized" | tr '_' '.')

    # Read port from file
    local port=$(cat "$conf_file" 2>/dev/null)

    # Skip if port is invalid
    if [[ ! "$port" =~ ^[0-9]+$ ]]; then
      rm -f "$conf_file"
      processed_count=$((processed_count + 1))
      continue
    fi

    # Check if host already exists in JSON (existing entries have priority)
    local existing_port=$(tunnel_json_get "$hostname")

    if [ -z "$existing_port" ]; then
      # Host doesn't exist in JSON - add it with preserved timestamp
      local timestamp=$(stat -c %Y "$conf_file" 2>/dev/null || stat -f %m "$conf_file" 2>/dev/null)
      local timestamp_iso=$(date -u -d "@$timestamp" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -r "$timestamp" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null)

      # Add new entry using jq (atomic operation with automatic backup)
      jq_update '.tunnels[$host] = {"port": ($port | tonumber), "created": $timestamp, "last_used": $timestamp, "connection_count": 1}' \
        "$izopen_conf_tunnels_json" \
        --arg host "$hostname" \
        --arg port "$port" \
        --arg timestamp "$timestamp_iso" 2>/dev/null

      migrated_count=$((migrated_count + 1))
    else
      # Host already exists in JSON - skip (existing data takes priority)
      skipped_count=$((skipped_count + 1))
    fi

    # Delete migrated or skipped .conf file
    rm -f "$conf_file"

    # Update progress counter
    processed_count=$((processed_count + 1))

    # Show progress every N files
    if [ $((processed_count % progress_interval)) -eq 0 ]; then
      local percentage=$((processed_count * 100 / conf_count))
      echo "Processing: $processed_count/$conf_count ($percentage%)..."
    fi
  done < <(find "$izopen_conf_hosts_dir" -maxdepth 1 -type f -name '*.conf' 2>/dev/null | sort)

  # Show final migration statistics
  echo "Migration completed: $migrated_count new hosts added, $skipped_count existing hosts preserved"

  # Remove hosts directory if empty
  if rmdir "$izopen_conf_hosts_dir" 2>/dev/null; then
    echo "Legacy hosts directory removed"
  fi
}

# Find available port in specified range
# Reads all ports from tunnels.json and finds first gap or next port after last used
# Usage: find_available_port [min_port] [max_port] [mode]
# Parameters:
#   $1 - Minimum port number (default: 1024)
#   $2 - Maximum port number (default: 65535)
#   $3 - Mode: "first" (find first gap) or "last" (next after last used)
# Algorithm: Reads all ports from JSON, finds first gap in sequence, or returns prev+1
function find_available_port() {
  local min_port="${1:-1024}"
  local max_port="${2:-65535}"
  local mode="${3:-first}"  # first o last

  # Return min_port if JSON doesn't exist (first tunnel ever)
  [ ! -e "$izopen_conf_tunnels_json" ] && echo "$min_port" && return 0

  if [[ "$mode" == "first" ]]; then
    # Find first available port (first gap in sequence)
    jq -r '.tunnels[].port' "$izopen_conf_tunnels_json" 2>/dev/null | \
      sort -n | uniq | \
      awk -v min="$min_port" -v max="$max_port" '
        BEGIN{prev=min-1; found=0}
        {
          if($1<=prev || $1<min || $1>max) next;
          if($1-prev>1) {print prev+1; found=1; exit}
          prev=$1
        }
        END{if(!found && prev<max) print prev+1}
      '
  else
    # Find last port + 1
    local last_port=$(jq -r '.tunnels[].port' "$izopen_conf_tunnels_json" 2>/dev/null | sort -n | tail -n1)
    if [ -z "$last_port" ]; then
      echo "$min_port"
    else
      echo $((last_port + 1))
    fi
  fi
}

function helper_tunnel_create() {
  # Initialize JSON if needed
  tunnel_json_init

  # Remove legacy files (one-time cleanup)
  [ -e "$izopen_conf_dir/socks_port_current.conf" ] && rm -f "$izopen_conf_dir/socks_port_current.conf"
  [ -e "$izopen_cache_dir/tunnel.conf" ] && rm -f "$izopen_cache_dir/tunnel.conf"
  [ -e "$izopen_conf_dir/proxychains" ] && rm -f "$izopen_conf_dir"/proxychains/*.conf && rmdir "$izopen_conf_dir/proxychains" 2>/dev/null

  # Get existing port for this host from JSON
  tunnel_port_create=$(tunnel_json_get "$host")

  # Don't create a new tunnel if it's already opened
  if [ -n "$tunnel_port_create" ]; then
    nc $nc_opts 127.0.0.1 "$tunnel_port_create" </dev/null 2>/dev/null
    [ $? != 0 ] && tunnel_create=1 || tunnel_create=0
  fi

  # Manage tunnel creation
  if [ "$tunnel_create" = 1 ]; then
    if [ -z "$tunnel_port_create" ]; then
      # Find first free usable port
      tunnel_port_create="$(find_available_port ${tunnel_port_min} ${tunnel_port_max} first)"
    fi

    # Save/update port in JSON with metadata
    tunnel_json_set "$host" "$tunnel_port_create"

    # Update proxychains config with the newly created tunnel port
    # This ensures proxy.conf is always in sync with the latest tunnel
    make_proxychains_conf "$tunnel_port_create" > "$izopen_conf_proxychains_conf"
    chmod 600 "$izopen_conf_proxychains_conf"
  fi
}

# Check if tunnel port is valid
# Validates port is non-empty, numeric, and within allowed range
# Usage: is_valid_tunnel_port <port>
# Returns: 0 if valid, 1 if invalid
function is_valid_tunnel_port() {
  local port="$1"
  [[ -n "$port" ]] && [[ "$port" =~ ^[0-9]+$ ]] && \
  [[ $port -ge $tunnel_port_min && $port -le $tunnel_port_max ]]
}

# Use an already opened tunnel
# Reads last used port from proxy.conf (highest priority) or tunnels.json (fallback)
# No longer writes to separate tunnel.conf (eliminated redundancy)
# Usage: helper_tunnel_use
function helper_tunnel_use() {
  #tunnel_port_use=$(LANG=C yad --title="izOpen SSH Proxy" --entry --entry-text=$tunnel_port_use --text="Inserire la porta del Proxy Socks \nCompresa fra $tunnel_port_min e $tunnel_port_max\n" 2>/dev/null)

  if [[ -z "$tunnel_port_use" ]]; then
    # Read last used port from proxychains config (highest priority)
    # This is the most recently used port in actual practice
    if [[ -e "$izopen_conf_proxychains_conf" ]]; then
      tunnel_port_use=$(grep -E '^socks5' "$izopen_conf_proxychains_conf" 2>/dev/null | awk '{print $3}')
    fi

    # Fallback: get the most recently used tunnel from JSON if proxy.conf doesn't exist
    # This works by sorting all tunnels by last_used timestamp and taking the most recent
    if [[ -z "$tunnel_port_use" && -e "$izopen_conf_tunnels_json" ]]; then
      tunnel_port_use=$(jq -r '.tunnels | to_entries | sort_by(.value.last_used) | reverse | .[0].value.port // empty' "$izopen_conf_tunnels_json" 2>/dev/null)
    fi

    # Request if we must use the last used port (or enter a new one if empty)
    tunnel_port_use=$(dialog_entry_port "$tunnel_port_use" "$tunnel_port_min" "$tunnel_port_max")
  fi

  # Note: Port is now stored in tunnels.json (per-host) and proxy.conf (last global)
  # No need for separate tunnel.conf file (eliminated redundancy)
}

# Manage SSH tunnel creation and usage based on schema and flags
# Orchestrates tunnel creation for ssh:// schemas and tunnel usage for other schemas
# Sets up proxychains4 configuration if tunnel is used
# Validates tunnel port is within allowed range (tunnel_port_min to tunnel_port_max)
# Uses global variables: $schema, $tunnel_use, $tunnel_use_force, $tunnel_port_use
function helper_tunnel_manage() {
  # verify if needed to create the ssh tunnel only if the uri is ssh://
  case ${schema} in
    ssh)
        # by default don't use tunnel if the schema is ssh and is not forced
        [ "$tunnel_use_force" = 0 ] && tunnel_use=0
        helper_tunnel_create
        ;;
  esac

  # ask for a port if we want use a tunnel
  if [ $tunnel_use = 1 ] ; then
      helper_tunnel_use
    else
      tunnel_port_use=""
  fi

  # create the proxychains4 config
  if [[ $tunnel_use = 1 ]] && is_valid_tunnel_port "$tunnel_port_use"; then
    # Generate proxychains config with the actual port being used
    make_proxychains_conf "$tunnel_port_use" > "$izopen_conf_proxychains_conf"

    # proxychains configuration
    helper_prepend="proxychains4 -f $izopen_conf_proxychains_conf "

  #  else
  #    [ ! -z $tunnel_port_use ] && LANG=C yad --center --error --text="La porta specificata non √® valida: $tunnel_port_use\n\nInserire una porta compresa fra $tunnel_port_min e $tunnel_port_max" 2>/dev/null && unset tunnel_port_use
  fi

  # don't use tunnel socks proxy if the port is not specified or wrong
  [ -z $tunnel_port_use ] && tunnel_use=0
}

function print_log_header() {
  # print the parsed fields
  echo "----------------------------------------------------------------------------------------"
  echo "$(date +"%Y-%m-%d %H:%M:%S %Z") user:[$USER] uid:[$UID] uri:[$uri_safe]"
  [ $debug = 1 ] && print_log_debug
  echo "-- output ------------------------------------------------------------------------------"
}

function print_log_output() {
  dialog_text_info "${izopen_log_file}"
}

function print_log_footer() {
  echo "----------------------------------------------------------------------------------------"
}

function print_log_debug() {
  # print the parsed fields
  echo "-- debug -------------------------------------------------------------------------------"
  cat <<EOF
                uri: ${uri}
             schema: ${schema}
           username: ${username}
           password: ${password}
               host: ${host}
               port: ${port}
               path: ${path}
      tunnel_create: ${tunnel_create} - port: ${tunnel_port_create}
         tunnel_use: ${tunnel_use} - port: ${tunnel_port_use}
        helper_name: ${helper_name[$schema]}
         helper_cmd: ${helper_cmd[$schema]}
        helper_opts: ${helper_opts[$schema]}
        helper_conf: ${helper_conf[$schema]}
     helper_prepend: ${helper_prepend}
                cmd: $(printf '%q ' "${izopen_connect[@]}")
EOF
  echo "----------------------------------------------------------------------------------------"
}

#
# URI parsing function
#
# The function creates global variables with the parsed results.
# It returns 0 if parsing was successful or non-zero otherwise.
#
# [schema://][user[:password]@]host[:port][/path][?[arg1=val1]...][#fragment]
#
# thanks to: https://wp.vpalos.com/537/uri-parsing-using-bash-built-in-features/
function uri_parser() {
    # uri capture
    uri="$@"

    # safe escaping
    uri="${uri//\`/%60}"
    uri="${uri//\"/%22}"

    # Top level URI parsing with regex
    # Pattern breakdown (13 capture groups):
    # (1) (2)        Full schema    -> (([a-z]{3,6}):\/\/)?
    # (3)            Full address   -> ((([^:]+)(:([^@\/]*))?@)?([^:\/?]+)(:([0-9]+))?)
    #    (4)         User+pass      -> (([^:]+)(:([^@\/]*))?@)?
    #       (5)      Username       -> ([^:]+)
    #       (6)(7)   Password       -> (:([^@\/]*))?
    #    (8)         Host           -> ([^:\/?]+)
    #    (9)(10)     Port           -> (:([0-9]+))?
    # (11)           Path           -> (\/[^?]*)?
    # (12)           Query          -> (\?[^#]*)?
    # (13)           Fragment       -> (#.*)?
    pattern='^(([a-z]{3,6}):\/\/)?((([^:]+)(:([^@\/]*))?@)?([^:\/?]+)(:([0-9]+))?)(\/[^?]*)?(\?[^#]*)?(#.*)?$'
    [[ "$uri" =~ $pattern ]] || return 1;

    # Component extraction from BASH_REMATCH array
    uri=${BASH_REMATCH[0]}          # Full matched URI
    uri_schema=${BASH_REMATCH[2]}   # Protocol (ssh, rdp, vnc, http, etc.)
    uri_address=${BASH_REMATCH[3]}  # Full address part (user:pass@host:port)
    uri_username=${BASH_REMATCH[5]} # Username
    uri_password=${BASH_REMATCH[7]} # Password
    uri_host=${BASH_REMATCH[8]}     # Hostname or IP
    uri_port=${BASH_REMATCH[10]}    # Port number
    uri_path=${BASH_REMATCH[11]}    # Path (/path/to/resource)
    uri_query=${BASH_REMATCH[12]}   # Query string (?arg1=val1&arg2=val2)
    uri_fragment=${BASH_REMATCH[13]} # Fragment (#anchor)

    # path parsing
    count=0
    path="$uri_path"
    pattern='^/+([^/]+)'
    while [[ $path =~ $pattern ]]; do
        eval "uri_parts[$count]=\"${BASH_REMATCH[1]}\""
        path="${path:${#BASH_REMATCH[0]}}"
        let count++
    done

    # query parsing
    count=0
    query="$uri_query"
    pattern='^[?&]+([^= ]+)(=([^&]*))?'
    while [[ $query =~ $pattern ]]; do
        eval "uri_args[$count]=\"${BASH_REMATCH[1]}\""
        eval "uri_arg_${BASH_REMATCH[1]}=\"${BASH_REMATCH[3]}\""
        query="${query:${#BASH_REMATCH[0]}}"
        let count++
    done

    # return success
    return 0
}

function uri_unset() {
  unset uri uri_schema uri_address uri_username uri_password uri_host uri_port uri_path uri_query uri_fragment count query pattern
}

function confirm () {
    # call with a prompt string or use a default
    read -r -p "${1:-Are you sure? [y/N]} " -n 1 response
    case $response in
        [yY][eE][sS]|[yY])
            echo
            true
            ;;
        *)
            echo
            false
            ;;
    esac
}

#########################################################################
# URI HELPER FUNCTIONS
# Extract clipboard and sanitization logic for better maintainability
#########################################################################

# Get password from clipboard if clipboard_use=1 and password is empty
# Clears clipboard after reading for security
# Returns password via stdout
function get_password_from_clipboard() {
  [ $clipboard_use -ne 1 ] && return 1

  local clipboard

  case $OSTYPE in
    cygwin*|msys*)
      # Windows cygwin/msys2 env use /dev/clipboard for sharing
      clipboard=$(cat /dev/clipboard)
      echo -n " " > /dev/clipboard
      ;;
    *)
      clipboard="$($clipboard_cmd_paste)"
      # Remove password from clipboard
      # FIXME: Using workaround because xsel doesn't clean the clipboard - using SPACE
      # Note: single space passwords won't work with this workaround
      echo -e -n ' ' | $clipboard_cmd_clear
      ;;
  esac

  # Return early if clipboard is empty or space
  [[ -z "$clipboard" || "$clipboard" == " " ]] && return 1

  # Return clipboard contents
  echo "$clipboard" | tr -d [:cntrl:]
}

# Sanitize URI for logging by removing password
# Uses bash parameter expansion to replace password in URI with empty string
# Returns sanitized URI via stdout
# Usage: sanitize_uri_for_logging "uri" "password"
function sanitize_uri_for_logging() {
  local uri="$1"
  local password="$2"

  if [ -z "$password" ]; then
    echo "$uri"
  else
    # Remove :password from URI using bash parameter expansion
    echo "${uri//:$password/}"
  fi
}

# Open URI by dispatching to appropriate protocol helper
# Main function that orchestrates URI parsing, password handling, tunnel management, and execution
# Supports: ssh, telnet, rdp, vnc, sftp, ftp, http, https, smb, cifs
# Handles password extraction from clipboard if not in URI
# Creates sanitized URI for safe logging (removes password)
# Manages SSH tunnel creation/usage based on schema and tunnel flags
function uri_open() {
  local uri="$1"
  shift
  local args="$@"

  # parse the uri
  uri_parser "$uri"
  local schema="$uri_schema"
  local username="$uri_username"
  local password="$uri_password"

  # Try to obtain password from clipboard if not in URI
  if [ -z "$password" ]; then
    local clipboard_password=$(get_password_from_clipboard)
    [ -n "$clipboard_password" ] && password="$clipboard_password"
  fi

  local host="$uri_host"
  local port="$uri_port"
  local path="$uri_path"

  # Create sanitized URI for safe logging (removes password)
  local uri_safe=$(sanitize_uri_for_logging "$uri" "$password")


  uri_unset

  # force the usage of ssh tunnel for every openened url
  [ $tunnel_use_force = 1 ] && tunnel_use=1

  # WORKAROUND: Use an already estabilished ssh tunnel and open default http handler defining schema as http
  [[ $tunnel_use -eq 1 && -z "$uri" ]] && schema=http

  # Map https and about to http (they use the same handler)
  [[ "$schema" == "https" || "$schema" == "about" ]] && schema="http"

  ## customize the following uri for command associations:
  case $schema in
    ssh|telnet|rdp|vnc|sftp|ftp|http|smb|cifs|file)
      # create or use ssh tunnel if required
      case $schema in
        ssh)
          # here only to mantain tunnel_create=1 if defined
          ;;
        *)
          # only ssh schema can be used to create a tunnel
          tunnel_create=0
          ;;
      esac
      # manage the use or creation of ssh tunnel
      [[ "$tunnel_create" = 1 || "$tunnel_use" = 1 ]] && helper_tunnel_manage "$uri"

      # obtain commands to use to connect
      helper_${schema} "$uri"

      # prepend proxychains or other commands if helper_prepend is set
      if [ ! -z "$helper_prepend" ] && [ "$helper_prepend_skip" != "1" ]; then
        # convert helper_prepend string to array and prepend to izopen_connect
        read -ra prepend_array <<< "$helper_prepend"
        izopen_connect=("${prepend_array[@]}" "${izopen_connect[@]}")
      fi

      # log the command execution
      print_log_header

      # make the connection to the remote server
      "${izopen_connect[@]}"
      RETVAL=$?

      # for safety reasons unset the password after execution
      unset password

      # log the command output if there was an error
      [ $RETVAL != 0 ] && echo "--> Exit code from command: $RETVAL" && print_log_output
      ;;
    *)
      echo "ERROR: invalid URI specified: $uri"
      return 1;
      ;;
  esac
}

###################################################################
#################### default program menu and arguments validations
###################################################################

# usage help menu
function _usage()  {
  _PROG=$( echo ${0##*/} )
  cat <<EOF
$NAME - $DESCRIPTION
written by Ugo Viti <u.viti@wearequantico.it>
version: $VERSION - release: $VERSION_DATE

Usage: $_PROG [options] URI

Options:
  -h, --help                Show help options
  -v, --version             Show version information
  -d, --debug               Enable debug (default: $debug)
  -u, --uri                 Specify the URI to open (you can also specify the URL as last argument without this option)
  -t, --terminal            Open compatible schema using external terminal gui (default: $terminal_use)
  -f, --force-tunnel        Force the usage request of an already estabilished ssh tunnel when opening the uri (default: $tunnel_use_force)
  -c, --clipboard-password  Force the usage of clipboard contents as default password when connecting (default: $clipboard_use)
  -p, --port                Use the specified socks port to connect using reverse tunnel (default: request the port to use)
  --mkconfig                Create default config file, overwriting it if already exist (default location: $izopen_conf_file)

Examples:
  # general usage:
  $ $_PROG uri://username:password@address:port

  # open a http web page:
  $ $_PROG http://www.example.com

  # open a http web page specifing username and password:
  $ $_PROG http://john:doe@www.example.com

  # open a ssh connection specifing username and port:
  $ $_PROG ssh://root@secure.example.com:222

  # open a rdp connection specifing username and password:
  $ $_PROG rdp:///Administrator:password@server

  # open a rdp connection specifing domain/username and password and port:
  $ $_PROG rdp://DOMAIN/Administrator:password@server:33189

  # open a rdp connection specifing username@domain and password and port:
  $ $_PROG rdp://Administrator@example.com:password@server:33189

  # open a vnc connection specifing password and port:
  $ $_PROG vnc://SUPERs3cur3PWD@server:5902

  # open a smb file share with default file manager:
  $ $_PROG smb://Administrator:password@server

  # open a http browser using an already connected ssh tunnel (ask for the port):
  $ $_PROG -t

  # open a http browser using an already connected ssh tunnel specifing the port (-t option is implicit for -p):
  $ $_PROG -p 2069
EOF
}

# check if all required system commands are installed (must run before migration)
check_system_commands $system_commands

# migrate legacy tunnel configuration to JSON (automatic, one-time)
migrate_legacy_tunnels

# if not arguments print usage and exit
[ $# = 0 ] && _usage && exit 1

# define command short and long options
_optionsShort="hvu:dtfcp:"
_optionsLong="help,version,uri:,debug,terminal,force-tunnel,clipboard-password,port,mkconfig"

# options may be followed by one colon to indicate they have a required argument
if ! options=$(getopt -o $_optionsShort -l $_optionsLong -- "$@"); then
  # something went wrong, getopt will put out an error message for us
  echo "exiting... incorrect options provided. use -h for help" >&2
  exit 1
fi

eval set -- "$options"

while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help)
      _usage
      exit 1
      ;;
    -v|--version)
      echo "$NAME version $VERSION ($VERSION_DATE)"
      exit 0
      ;;
    -u|--uri)
      # for options with required arguments, an additional shift is required
      shift
      uri="$1"
      ;;
    -d|--debug)
      [ $debug = 1 ] && debug=0 || debug=1
      ;;
    -t|--terminal)
      [ $terminal_use = 1 ] && terminal_use=0 || terminal_use=1
      ;;
    -f|--force-tunnel)
      [ $tunnel_use_force = 1 ] && tunnel_use_force=0 || tunnel_use_force=1
      ;;
    -c|--clipboard-password)
      [ $clipboard_use = 1 ] && clipboard_use=0 || clipboard_use=1
      ;;
    -p|--port)
      # specify the tunnel port to use (ssh schema excluded). it involves --force-tunnel
      shift
      tunnel_use_force=1
      # use the specified tunnel socks port
      tunnel_port_use=$1
      ;;
    --mkconfig)
      if [ -e "$izopen_conf_file" ]; then
          confirm "WARNING: you are replacing the previous config file: $izopen_conf_file - Are you sure? [y/N]:" && make_default_config > "$izopen_conf_file"
        else
          make_default_config > "$izopen_conf_file"
      fi
      exit $?
      ;;
    (--) shift; break;;
    (-*) echo "ERROR: unrecognized option: '$1'" 1>&2; exit 1;;
    (*) _usage ; echo "invalid switch specified - abort." >&2 ; exit 1 ;;
  esac
  # for testing purposes:
  #echo "$1"
  shift
done

# if the -u|--uri switch is not used, then read the latest argument if exist
[ -z "$uri" ] && uri="$@"
[[ -z "$uri" && $tunnel_use_force -eq 0 ]] && echo "ERROR: no URI specified" && exit 1

# create defualt user config file if not exist
[ ! -e "$izopen_conf_file" ] && make_default_config > "$izopen_conf_file"

# detect the appropriate dialog tool based on desktop environment
detect_dialog_tool

uri_open "$uri" 2>&1 | tee -a "${izopen_log_file}"

# be sure to unset all dangerous variables on exit, error, or normal termination
trap "unset password SSHPASS" EXIT ERR
